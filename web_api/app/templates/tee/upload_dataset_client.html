{% extends "base.html" %}

{% block title %}Upload Dataset - Secure Client-Side Encryption{% endblock %}

{% block content %}
<div style="margin-bottom: 2rem;">
    <a href="{{ url_for('tee_web.session_detail', session_id=session.id) }}" style="color: #667eea; text-decoration: none;">‚Üê Back to {{ session.name }}</a>
</div>

<h1 style="margin-bottom: 1rem;">Upload Dataset (Client-Side Encrypted)</h1>
<p style="color: #666; margin-bottom: 2rem;">Dataset: <strong>{{ dataset.name }}</strong></p>

<!-- Security Warning -->
<div style="background: #fff3cd; padding: 1.5rem; border-radius: 10px; border-left: 4px solid #ffc107; margin-bottom: 2rem;">
    <h4 style="color: #856404; margin-bottom: 0.5rem;">üîí Zero-Trust Security Protocol</h4>
    <ul style="color: #856404; margin-left: 1.5rem; font-size: 0.9rem;">
        <li>Your data is encrypted <strong>in your browser</strong> before upload</li>
        <li>The web server <strong>never sees</strong> your plaintext data</li>
        <li>Data is uploaded directly to the Trusted Execution Environment (TEE)</li>
        <li>Verify the attestation before uploading sensitive data</li>
    </ul>
</div>

<!-- Step 1: Verify TEE Attestation -->
<div id="step-attestation" class="upload-step" style="background: white; padding: 2rem; border-radius: 10px; margin-bottom: 1.5rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
    <h3 style="margin-bottom: 1rem;">Step 1: Verify TEE Attestation</h3>
    <p style="color: #666; margin-bottom: 1rem;">Before uploading data, verify you're talking to a legitimate TEE.</p>
    
    <button id="btn-verify-attestation" class="btn btn-primary" onclick="verifyAttestation()">
        Fetch & Verify Attestation
    </button>
    
    <div id="attestation-result" style="margin-top: 1rem; display: none;">
        <div id="attestation-success" style="display: none; background: #d4edda; padding: 1rem; border-radius: 5px; border-left: 4px solid #28a745;">
            <strong style="color: #155724;">‚úì Attestation Verified</strong>
            <p style="color: #155724; margin: 0.5rem 0 0 0; font-size: 0.9rem;">TEE is running trusted code in a confidential VM</p>
            <details style="margin-top: 0.5rem;">
                <summary style="cursor: pointer; color: #155724; font-size: 0.85rem;">View attestation details</summary>
                <pre id="attestation-details" style="background: #f8f9fa; padding: 0.5rem; border-radius: 3px; font-size: 0.75rem; overflow-x: auto; margin-top: 0.5rem;"></pre>
            </details>
        </div>
        <div id="attestation-failure" style="display: none; background: #f8d7da; padding: 1rem; border-radius: 5px; border-left: 4px solid #dc3545;">
            <strong style="color: #721c24;">‚úó Attestation Failed</strong>
            <p id="attestation-error" style="color: #721c24; margin: 0.5rem 0 0 0; font-size: 0.9rem;"></p>
        </div>
    </div>
</div>

<!-- Step 2: Select File -->
<div id="step-file" class="upload-step" style="background: white; padding: 2rem; border-radius: 10px; margin-bottom: 1.5rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); opacity: 0.5; pointer-events: none;">
    <h3 style="margin-bottom: 1rem;">Step 2: Select Your Dataset File</h3>
    <input type="file" id="file-input" accept=".csv,.json,.parquet" style="padding: 0.5rem;">
    <p style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">Supported formats: CSV, JSON, Parquet</p>
    
    <div id="file-info" style="margin-top: 1rem; display: none; background: #e7f3ff; padding: 1rem; border-radius: 5px;">
        <strong>Selected file:</strong> <span id="file-name"></span><br>
        <strong>Size:</strong> <span id="file-size"></span>
    </div>
</div>

<!-- Step 3: Encrypt & Upload -->
<div id="step-upload" class="upload-step" style="background: white; padding: 2rem; border-radius: 10px; margin-bottom: 1.5rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); opacity: 0.5; pointer-events: none;">
    <h3 style="margin-bottom: 1rem;">Step 3: Encrypt & Upload</h3>
    <p style="color: #666; margin-bottom: 1rem;">Your data will be encrypted locally using the TEE's public key, then uploaded.</p>
    
    <button id="btn-upload" class="btn btn-primary" onclick="encryptAndUpload()" disabled>
        Encrypt & Upload to TEE
    </button>
    
    <div id="upload-progress" style="margin-top: 1rem; display: none;">
        <div style="background: #e9ecef; border-radius: 5px; height: 30px; overflow: hidden;">
            <div id="progress-bar" style="background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); height: 100%; width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 0.9rem;"></div>
        </div>
        <p id="upload-status" style="color: #666; margin-top: 0.5rem; font-size: 0.9rem;"></p>
    </div>
    
    <div id="upload-result" style="margin-top: 1rem; display: none;">
        <div id="upload-success" style="display: none; background: #d4edda; padding: 1rem; border-radius: 5px; border-left: 4px solid #28a745;">
            <strong style="color: #155724;">‚úì Upload Complete!</strong>
            <p style="color: #155724; margin: 0.5rem 0 0 0;">Your encrypted dataset is now available in the TEE.</p>
            <a href="{{ url_for('tee_web.session_detail', session_id=session.id) }}" class="btn btn-primary" style="margin-top: 1rem; display: inline-block;">Return to Session</a>
        </div>
        <div id="upload-failure" style="display: none; background: #f8d7da; padding: 1rem; border-radius: 5px; border-left: 4px solid #dc3545;">
            <strong style="color: #721c24;">‚úó Upload Failed</strong>
            <p id="upload-error" style="color: #721c24; margin: 0.5rem 0 0 0; font-size: 0.9rem;"></p>
        </div>
    </div>
</div>

<!-- Technical Details -->
<div style="background: #f8f9fa; padding: 1.5rem; border-radius: 10px; margin-top: 2rem;">
    <h4 style="color: #495057; margin-bottom: 0.5rem;">üîê Encryption Protocol</h4>
    <ul style="color: #6c757d; margin-left: 1.5rem; font-size: 0.85rem;">
        <li><strong>Hybrid Encryption:</strong> AES-256-GCM for data, RSA-OAEP for key wrapping</li>
        <li><strong>TEE Public Key:</strong> Extracted from verified attestation</li>
        <li><strong>Zero Trust:</strong> Plaintext never transmitted over network</li>
        <li><strong>Session Isolation:</strong> Re-encrypted with session-specific keys inside TEE</li>
    </ul>
</div>

<script>
    // Configuration
    const TEE_ENDPOINT = "{{ tee_endpoint }}";
    const UPLOAD_TOKEN = "{{ upload_token }}";
    const DATASET_ID = {{ dataset.id }};
    const SESSION_ID = {{ session.id }};
    
    let teePublicKey = null;
    let selectedFile = null;
    
    // Step 1: Verify TEE Attestation
    async function verifyAttestation() {
        const btn = document.getElementById('btn-verify-attestation');
        btn.disabled = true;
        btn.textContent = 'Verifying...';
        
        try {
            // Use CORS-enabled proxy for attestation
            const response = await fetch('/api/tee/attestation-proxy');
            if (!response.ok) {
                throw new Error(`Failed to fetch attestation: ${response.statusText}`);
            }
            
            const attestation = await response.json();
            
            // Extract the real PEM public key from the attestation response
            if (attestation && attestation.attestation && attestation.attestation.public_key) {
                teePublicKey = attestation.attestation.public_key;
                console.log('[TEE Upload] Using TEE public key:', teePublicKey);
            } else {
                throw new Error('TEE attestation response did not include a public key.');
            }
            
            // In production, verify:
            // 1. Attestation signature chain (JWT verification)
            // 2. Code measurement hash from attestation_token
            // 3. Hardware attestation (confidential_computing: true)
            
            document.getElementById('attestation-details').textContent = JSON.stringify(attestation, null, 2);
            document.getElementById('attestation-success').style.display = 'block';
            document.getElementById('attestation-result').style.display = 'block';
            
            // Enable next step
            enableStep('step-file');
            
        } catch (error) {
            document.getElementById('attestation-error').textContent = error.message;
            document.getElementById('attestation-failure').style.display = 'block';
            document.getElementById('attestation-result').style.display = 'block';
            btn.disabled = false;
            btn.textContent = 'Retry Verification';
        }
    }
    
    // File selection
    document.getElementById('file-input').addEventListener('change', function(e) {
        selectedFile = e.target.files[0];
        if (selectedFile) {
            document.getElementById('file-name').textContent = selectedFile.name;
            document.getElementById('file-size').textContent = formatFileSize(selectedFile.size);
            document.getElementById('file-info').style.display = 'block';
            enableStep('step-upload');
            document.getElementById('btn-upload').disabled = false;
        }
    });
    
    // Step 3: Encrypt and Upload
    async function encryptAndUpload() {
        if (!selectedFile || !teePublicKey) {
            alert('Please complete previous steps first');
            return;
        }
        
        const btn = document.getElementById('btn-upload');
        btn.disabled = true;
        document.getElementById('upload-progress').style.display = 'block';
        
        try {
            // Read file
            updateProgress(10, 'Reading file...');
            const fileData = await readFileAsArrayBuffer(selectedFile);
            
            // Encrypt data (using Web Crypto API)
            updateProgress(30, 'Encrypting data with TEE public key...');
            const encryptedData = await encryptData(fileData, teePublicKey);
            
            // Upload to TEE
            updateProgress(50, 'Uploading encrypted data to TEE...');
            await uploadToTEE(encryptedData);
            
            updateProgress(100, 'Complete!');
            document.getElementById('upload-success').style.display = 'block';
            document.getElementById('upload-result').style.display = 'block';
            
        } catch (error) {
            console.error('Upload error:', error);
            document.getElementById('upload-error').textContent = error.message;
            document.getElementById('upload-failure').style.display = 'block';
            document.getElementById('upload-result').style.display = 'block';
            btn.disabled = false;
        }
    }
    
    // Encryption using Web Crypto API
    async function encryptData(data, publicKeyPem) {
        // Generate random AES key
        const aesKey = await crypto.subtle.generateKey(
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt']
        );
        
        // Generate IV
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        // Encrypt data with AES
        const encryptedData = await crypto.subtle.encrypt(
            { name: 'AES-GCM', iv: iv },
            aesKey,
            data
        );
        
        // Export AES key as raw bytes
        const exportedKey = await crypto.subtle.exportKey('raw', aesKey);
        
        // Import TEE's RSA public key
        const rsaPublicKey = await importRSAPublicKey(publicKeyPem);
        
        // Encrypt AES key with RSA-OAEP
        const encryptedAESKey = await crypto.subtle.encrypt(
            {
                name: 'RSA-OAEP'
            },
            rsaPublicKey,
            exportedKey
        );
        
        return {
            encrypted_data: arrayBufferToBase64(encryptedData),
            encrypted_key: arrayBufferToBase64(encryptedAESKey),
            iv: arrayBufferToBase64(iv),
            algorithm: 'AES-256-GCM'
        };
    }
    
    // Import RSA public key from PEM format
    async function importRSAPublicKey(pemKey) {
        // Remove PEM header/footer and all non-base64 characters
        let pemContents = pemKey
            .replace(/-----BEGIN PUBLIC KEY-----/g, '')
            .replace(/-----END PUBLIC KEY-----/g, '')
            .replace(/[^A-Za-z0-9+/=]/g, '') // Only base64 chars
            .trim();

        // Log PEM for debugging
        console.log('[TEE Upload] Cleaned PEM contents:', pemContents);

        // Validate base64 length (should be multiple of 4)
        if (pemContents.length % 4 !== 0) {
            pemContents = pemContents.padEnd(pemContents.length + (4 - (pemContents.length % 4)), '=');
        }

        let binaryDer;
        try {
            binaryDer = atob(pemContents);
        } catch (e) {
            console.error('[TEE Upload] atob failed for PEM:', pemContents, e);
            throw new Error('Invalid PEM format: failed base64 decode');
        }
        const bytes = new Uint8Array(binaryDer.length);
        for (let i = 0; i < binaryDer.length; i++) {
            bytes[i] = binaryDer.charCodeAt(i);
        }

        // Import as RSA-OAEP key
        try {
            return await crypto.subtle.importKey(
                'spki',
                bytes.buffer,
                {
                    name: 'RSA-OAEP',
                    hash: 'SHA-256'
                },
                false,
                ['encrypt']
            );
        } catch (e) {
            console.error('[TEE Upload] importKey failed. PEM:', pemContents, 'Bytes:', bytes, e);
            throw new Error('Failed to import RSA public key: ' + e.message);
        }
    }
    
    async function uploadToTEE(encryptedData) {
        const response = await fetch(`${TEE_ENDPOINT}/upload`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${UPLOAD_TOKEN}`
            },
            body: JSON.stringify({
                dataset_id: DATASET_ID,
                session_id: SESSION_ID,
                encrypted_data: encryptedData.encrypted_data,
                encrypted_key: encryptedData.encrypted_key,
                iv: encryptedData.iv,
                algorithm: encryptedData.algorithm,
                filename: selectedFile.name,
                file_size: selectedFile.size
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || 'Upload failed');
        }
        
        const result = await response.json();
        
        // Notify web server that upload completed successfully
        // (TEE can't reach local dev server, so browser does the callback)
        try {
            await fetch('/api/tee/callback', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    entity_type: 'dataset',
                    entity_id: DATASET_ID,
                    status: 'available',
                    metadata: {
                        checksum: result.checksum,
                        file_size: selectedFile.size
                    },
                    timestamp: new Date().toISOString()
                })
            });
        } catch (callbackError) {
            console.error('Failed to notify web server:', callbackError);
            // Don't fail the upload if callback fails
        }
        
        return result;
    }
    
    // Utility functions
    function enableStep(stepId) {
        const step = document.getElementById(stepId);
        step.style.opacity = '1';
        step.style.pointerEvents = 'auto';
    }
    
    function updateProgress(percent, status) {
        document.getElementById('progress-bar').style.width = `${percent}%`;
        document.getElementById('progress-bar').textContent = `${percent}%`;
        document.getElementById('upload-status').textContent = status;
    }
    
    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }
    
    function readFileAsArrayBuffer(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }
    
    function arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.length; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }
</script>
{% endblock %}
